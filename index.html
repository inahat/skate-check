<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skate Check: Final</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #050505;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 15px;
            text-align: center;
            box-sizing: border-box;
        }

        /* CARD STYLE */
        .card {
            background: #151515;
            border: 1px solid #333;
            border-radius: 16px;
            padding: 20px;
            width: 100%;
            max-width: 380px;
            margin-bottom: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }

        #status-header { font-size: 3rem; font-weight: 900; text-transform: uppercase; line-height: 1; margin-bottom: 5px; }
        #status-sub { font-size: 1.2rem; font-weight: 500; text-transform: uppercase; color: #888; margin-bottom: 5px; }

        /* PREDICTION BOX */
        #prediction-box {
            background: rgba(46, 204, 113, 0.15); border: 1px solid #2ecc71; color: #2ecc71;
            padding: 10px; border-radius: 8px; margin-top: 15px; font-weight: bold;
            display: none; font-size: 0.95rem;
        }
        .pred-warning { background: rgba(243, 156, 18, 0.15) !important; border-color: #f39c12 !important; color: #f39c12 !important; }

        /* ACTION BUTTONS */
        .action-row { display: flex; gap: 8px; width: 100%; justify-content: center; margin-top: 15px; }
        .action-btn {
            background: #222; border: 1px solid #444; color: #ccc;
            padding: 12px; border-radius: 8px; flex-grow: 1; cursor: pointer;
            font-size: 0.85rem; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 6px;
        }
        .action-btn:hover { background: #333; color: #fff; border-color: #666; }

        /* MAGIC BUTTON */
        .magic-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none; color: white; margin-top: 15px; width: 100%;
            padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
            transition: transform 0.1s;
        }
        .magic-btn:active { transform: scale(0.98); }

        #tre-result {
            margin-top: 15px; padding: 15px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333; display: none;
            animation: fadeIn 0.3s;
        }
        .tre-percent { font-size: 2.5rem; font-weight: 900; display: block; margin-bottom: 5px; }
        .tre-msg { font-size: 0.9rem; color: #aaa; font-style: italic; }

        /* BADGES */
        .badge-row { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
        .badge { font-size: 0.75rem; padding: 4px 8px; border-radius: 4px; background: #222; color: #999; border: 1px solid #333; font-weight: 600; }
        
        .type-field { color: #f39c12; border-color: #f39c12; }
        .type-urban { color: #3498db; border-color: #3498db; }
        .type-covered { color: #2ecc71; border-color: #2ecc71; }
        .conf-high { color: #2ecc71; border-color: #2ecc71; }
        .conf-med { color: #f39c12; border-color: #f39c12; }
        .conf-low { color: #e74c3c; border-color: #e74c3c; }

        /* LOGIC BOX */
        #logic-container { display: none; margin-top: 15px; }
        #logic-box { text-align: left; font-size: 0.9rem; color: #bbb; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 4px solid #555; line-height: 1.5; }

        /* METRICS GRID */
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .metric { background: #222; padding: 10px; border-radius: 8px; display: flex; flex-direction: column; align-items: center; }
        .m-label { font-size: 0.7rem; color: #777; text-transform: uppercase; }
        .m-val { font-size: 1.1rem; font-weight: 700; margin-top: 4px; color: #fff; }

        /* CONTROLS */
        select, button, input { width: 100%; max-width: 380px; padding: 14px; background: #222; color: white; border: 1px solid #444; border-radius: 10px; font-size: 1rem; margin-bottom: 10px; box-sizing: border-box; }
        .search-container { display: flex; gap: 5px; width: 100%; max-width: 380px; margin-bottom: 15px; }
        input { margin-bottom: 0; }
        .go-btn { width: auto; margin-bottom: 0; background: #333; cursor: pointer;}
        
        #why-btn { background: transparent; border: 1px solid #444; font-size: 0.8rem; padding: 8px; width: auto; margin: 0 auto; display: none; color: #888; cursor: pointer; border-radius: 20px; }
        #why-btn:hover { border-color: #888; color: #fff; }

        .forecast-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #333; font-size: 0.9rem; }
        .forecast-row:last-child { border-bottom: none; }
        .dim { opacity: 0.4; }
        
        @keyframes fadeIn { from{opacity:0; transform:translateY(-10px);} to{opacity:1; transform:translateY(0);} }
    </style>
</head>
<body>

    <h2 style="font-size:1rem; color:#666; margin-top:0; text-transform:uppercase; letter-spacing:2px;">Skate Check: Final</h2>

    <select id="park-select" onchange="selectPark()">
        <option value="" disabled selected>Select Park...</option>
        
        <optgroup label="Field Locations (High Dew Risk)">
            <option value="51.6886,-0.0355" data-type="field">Waltham Cross</option>
            <option value="51.6908,-0.0105" data-type="field">Waltham Abbey</option>
            <option value="51.6242,-0.0166" data-type="field">Chingford (Chase Lane)</option>
            <option value="51.4221,-0.0715" data-type="field">Crystal Palace</option>
            <option value="51.5945,-0.0872" data-type="field">Lordship Rec</option>
        </optgroup>

        <optgroup label="Urban / Concrete (Standard)">
            <option value="51.4664,-0.1160" data-type="urban">Stockwell</option>
            <option value="51.5500,-0.1290" data-type="urban">Cantelowes</option>
            <option value="51.5365,-0.0392" data-type="urban">Victoria Park</option>
            <option value="51.4850,-0.1080" data-type="urban">Kennington</option>
        </optgroup>

        <optgroup label="Covered / Protected">
            <option value="51.5200,-0.2000" data-type="covered">BaySixty6 (Covered)</option>
            <option value="51.5072,-0.1158" data-type="covered">Southbank (Undercroft)</option>
            <option value="51.5100,-0.2450" data-type="covered">Acton (Sheltered)</option>
        </optgroup>
    </select>

    <div class="search-container">
        <input type="text" id="city-input" placeholder="Or search UK city..." onfocus="clearDropdown()" onkeydown="if(event.key === 'Enter') searchLocation()">
        <button class="go-btn" onclick="searchLocation()">Go</button>
    </div>

    <div class="card" id="main-card">
        <div id="status-header">--</div>
        <div id="status-sub">Select Location</div>
        
        <div class="badge-row">
            <div class="badge" id="type-badge" style="display:none">--</div>
            <div class="badge" id="rain-badge">--</div>
            <div class="badge" id="conf-badge" style="display:none;">--%</div>
        </div>

        <div id="prediction-box"></div>

        <!-- ACTION BUTTONS -->
        <div class="action-row" id="actions" style="display:none;">
            <button class="action-btn" onclick="openMaps()">üìç Map</button>
            <button class="action-btn" onclick="openTrafficCams()">üé• Cams</button>
            <button class="action-btn" onclick="shareResult()">üì§ Share</button>
        </div>
        
        <!-- TRE FLIP GENERATOR -->
        <button class="magic-btn" id="tre-btn" onclick="calcTreFlip()" style="display:none;">üîÆ 360 Flip Odds</button>
        
        <div id="tre-result">
            <span class="tre-percent" id="tre-val">--%</span>
            <span class="tre-msg" id="tre-msg">--</span>
        </div>
        
        <div style="margin-top:15px">
            <button id="why-btn" onclick="toggleReason()">Why is it this status?</button>
        </div>
        
        <div id="logic-container">
            <div id="logic-box">Waiting for data...</div>
        </div>
    </div>

    <div class="card dim" id="data-card">
        <div style="font-size:0.8rem; color:#666; text-transform:uppercase; margin-bottom:10px;">Evaporation Metrics</div>
        <div class="grid">
            <div class="metric">
                <span class="m-label">Sunset</span>
                <span class="m-val" id="val-sunset">--</span>
            </div>
            <div class="metric">
                <span class="m-label">Cloud Cover</span>
                <span class="m-val" id="val-cloud">--</span>
            </div>
            <div class="metric">
                <span class="m-label">Soil Wetness</span>
                <span class="m-val" id="val-soil">--</span>
            </div>
            <div class="metric">
                <span class="m-label">Vapor Deficit</span>
                <span class="m-val" id="val-vpd">--</span>
            </div>
        </div>
        <div style="margin-top:15px; padding-top:10px; border-top:1px solid #333;" id="forecast-container"></div>
    </div>

    <button onclick="getGPS()" style="background:none; border:none; text-decoration:underline; color:#666; font-size:0.8rem;">Use My GPS</button>

    <script>
        // GLOBALS
        let currentLat = 0;
        let currentLon = 0;
        let currentName = "";
        let currentStatus = "";
        let currentPrediction = "";

        // --- 1. MAGIC TRE FLIP LOGIC ---
        function calcTreFlip() {
            const btn = document.getElementById('tre-btn');
            const resultBox = document.getElementById('tre-result');
            const valBox = document.getElementById('tre-val');
            const msgBox = document.getElementById('tre-msg');
            
            // Random float 0.0 to 1.0
            const roll = Math.random();
            
            let percent = 0;
            let message = "";
            let color = "#e74c3c"; // Red by default

            if (roll > 0.90) {
                // 10% Chance of Success
                percent = 100;
                color = "#2ecc71"; // Green
                const wins = [
                    "The skate gods smile upon you.",
                    "First try. No warm up.",
                    "Bolts. Guaranteed.",
                    "Steez levels critical.",
                    "The universe provides.",
                    "Sponsor tape incoming."
                ];
                message = wins[Math.floor(Math.random() * wins.length)];
            } else {
                // 90% Chance of Fail (0-8%)
                percent = Math.floor(Math.random() * 9); 
                const fails = [
                    "My sources say wheelbite.",
                    "Outlook not so good.",
                    "Primo landing imminent.",
                    "Don't count on it.",
                    "Shinburgers on the menu.",
                    "Focus on your ollies first.",
                    "Try again later.",
                    "Your trucks are too tight.",
                    "Gravity says no."
                ];
                message = fails[Math.floor(Math.random() * fails.length)];
            }

            valBox.innerText = percent + "%";
            valBox.style.color = color;
            msgBox.innerText = message;
            
            // HIDE BUTTON (Only run once per park)
            btn.style.display = "none";
            
            // SHOW RESULT
            resultBox.style.display = "block";
            resultBox.style.borderColor = color;
        }

        // --- 2. TRAFFIC CAM LOGIC ---

        function openMaps() {
            if(currentLat === 0) return;
            window.open(`https://www.google.com/maps/search/?api=1&query=${currentLat},${currentLon}`, '_blank');
        }

        function openTrafficCams() {
            if(!currentName) return;
            let cleanName = currentName.replace(" (Bowl)", "").replace(" (Holdbrook)", "").replace(" (Town Mead)", "").replace(" (Chase Lane)", "");
            const query = `live traffic camera ${cleanName}`;
            window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank');
        }

        async function shareResult() {
            const text = `Skate Check: ${currentName}\nStatus: ${currentStatus}\n${currentPrediction}`;
            if (navigator.share) {
                try { await navigator.share({ title: 'Skate Check', text: text }); } 
                catch (err) { console.log('Share failed', err); }
            } else {
                navigator.clipboard.writeText(text);
                alert("Result copied to clipboard!");
            }
        }

        // --- 3. PHYSICS CALCULATIONS ---

        function calculateVPD(T, RH) {
            const es = 0.6108 * Math.exp((17.27 * T) / (T + 237.3));
            const ea = es * (RH / 100);
            return (es - ea);
        }

        function calculateDryingScore(vpd, windKph, solarWatts, parkType) {
            let score = vpd * (1 + (windKph * 0.15));
            if (parkType !== 'covered') score += (solarWatts / 150); 
            return score;
        }

        function predictDryTime(hourlyData, startIndex, parkType, currentAccumulation) {
            const dryingThreshold = (parkType === 'field') ? 3.0 : 1.5;
            let acc = currentAccumulation;
            
            for(let i = 1; i < 24; i++) {
                const idx = startIndex + i;
                if(idx >= hourlyData.time.length) break;

                const code = hourlyData.weather_code[idx];
                const precip = hourlyData.precipitation[idx];
                const ground = hourlyData.soil_temperature_0cm[idx] || hourlyData.temperature_2m[idx];
                const dew = hourlyData.dew_point_2m[idx];
                
                const margin = (new Date(hourlyData.time[idx]).getHours() >= 4 && new Date(hourlyData.time[idx]).getHours() <= 11) ? 
                               ((parkType === 'field') ? 4.0 : 2.5) : 1.5;

                if ((precip > 0 || code >= 50) || (ground - dew < margin)) {
                    acc = 0;
                } else {
                    const vpd = calculateVPD(hourlyData.temperature_2m[idx], hourlyData.relative_humidity_2m[idx]);
                    const hourScore = calculateDryingScore(vpd, hourlyData.wind_speed_10m[idx], hourlyData.shortwave_radiation[idx], parkType);
                    acc += hourScore;
                }

                if (acc >= dryingThreshold) return hourlyData.time[idx].split('T')[1];
            }
            return null;
        }

        // --- 4. UI HELPERS ---

        function getSettings(type, isMorning) {
            let settings = { margin: 1.5, desc: "Standard" };
            if (type === 'field') {
                settings.margin = isMorning ? 4.0 : 2.5;
                settings.desc = "Field (High Risk)";
            } else if (type === 'covered') {
                settings.margin = 0.5;
                settings.desc = "Covered";
            } else {
                settings.margin = isMorning ? 2.5 : 1.5;
                settings.desc = "Urban";
            }
            return settings;
        }

        function toggleReason() {
            const el = document.getElementById('logic-container');
            const btn = document.getElementById('why-btn');
            if (el.style.display === 'block') {
                el.style.display = 'none';
                btn.innerText = "Why is it this status?";
            } else {
                el.style.display = 'block';
                btn.innerText = "Hide reasoning";
            }
        }

        function selectPark() {
            const select = document.getElementById('park-select');
            const val = select.value;
            let type = 'urban';
            if (select.selectedIndex >= 0) {
                 type = select.options[select.selectedIndex].getAttribute('data-type') || 'urban';
            }
            document.getElementById('city-input').value = "";
            if(val) {
                const [lat, lon] = val.split(',');
                fetchData(lat, lon, type, select.options[select.selectedIndex].text);
            }
        }

        function clearDropdown() { document.getElementById('park-select').selectedIndex = 0; }

        async function searchLocation() {
            clearDropdown();
            const input = document.getElementById('city-input').value;
            if(!input) return;
            document.getElementById('status-header').innerText = "...";
            document.getElementById('status-sub').innerText = "Searching UK...";
            const url = `https://geocoding-api.open-meteo.com/v1/search?name=${input}&count=5&language=en&format=json`;
            try {
                const res = await fetch(url);
                const data = await res.json();
                if(data.results) {
                    const ukLoc = data.results.find(r => r.country_code === 'GB');
                    if (ukLoc) {
                        fetchData(ukLoc.latitude, ukLoc.longitude, 'urban', ukLoc.name);
                    } else {
                        alert("City not found in UK.");
                        document.getElementById('status-header').innerText = "--";
                    }
                }
            } catch(e) { console.error(e); }
        }

        function getGPS() {
            if(navigator.geolocation) {
                clearDropdown();
                document.getElementById('status-sub').innerText = "Locating...";
                navigator.geolocation.getCurrentPosition(
                    pos => fetchData(pos.coords.latitude, pos.coords.longitude, 'urban', "My Location"),
                    err => alert("GPS Error")
                );
            }
        }

        // --- 5. CORE LOGIC ---

        async function fetchData(lat, lon, parkType, name) {
            currentLat = lat; currentLon = lon; currentName = name;
            document.getElementById('status-sub').innerText = name;
            document.getElementById('actions').style.display = "flex";
            
            // RESET UI FOR NEW PARK
            document.getElementById('logic-container').style.display = 'none';
            document.getElementById('why-btn').style.display = 'none';
            document.getElementById('prediction-box').style.display = 'none';
            document.getElementById('status-header').innerText = "...";
            
            // RESET TRE FLIP FOR NEW PARK
            document.getElementById('tre-btn').style.display = "block"; 
            document.getElementById('tre-result').style.display = 'none';
            
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m,soil_temperature_0cm,dew_point_2m,is_day,cloud_cover,shortwave_radiation,soil_moisture_0_to_1cm&hourly=soil_temperature_0cm,dew_point_2m,precipitation,weather_code,relative_humidity_2m,wind_speed_10m,temperature_2m,cloud_cover,shortwave_radiation&daily=sunset&past_days=1&forecast_days=2&timezone=GMT`;

            try {
                const res = await fetch(url);
                const data = await res.json();
                analyze(data, parkType);
            } catch(e) {
                console.error(e);
            }
        }

        function analyze(data, parkType) {
            const cur = data.current;
            const hourly = data.hourly;
            const daily = data.daily;
            
            const now = new Date();
            const nowISO = now.toISOString().slice(0, 13);
            let idx = hourly.time.findIndex(t => t.startsWith(nowISO));
            if(idx === -1) idx = 24 + now.getHours(); 

            // EXTRACT
            let groundTemp = cur.soil_temperature_0cm;
            if (groundTemp === null) groundTemp = cur.temperature_2m;
            
            const dewPoint = cur.dew_point_2m;
            const humidity = cur.relative_humidity_2m;
            const wind = cur.wind_speed_10m;
            const solar = cur.shortwave_radiation;
            const cloud = cur.cloud_cover;
            const soilMoist = cur.soil_moisture_0_to_1cm;
            
            const spread = (groundTemp - dewPoint).toFixed(1);
            const currentHour = now.getHours();
            const isMorning = (currentHour >= 4 && currentHour <= 11);

            const vpd = calculateVPD(cur.temperature_2m, humidity);

            // HISTORY
            let wasWet = false;
            let wetTime = 0;
            let accumulatedDryingScore = 0;
            let lastRainHours = -1;

            for(let i=0; i<=24; i++) {
                const hIdx = idx - i;
                if(hIdx < 0) continue;
                
                const code = hourly.weather_code[hIdx];
                const precip = hourly.precipitation[hIdx];
                
                if ((precip > 0 || code >= 50) && lastRainHours === -1) lastRainHours = i;

                if (i <= 12) {
                    let hGround = hourly.soil_temperature_0cm[hIdx] || hourly.temperature_2m[hIdx];
                    let hDew = hourly.dew_point_2m[hIdx];
                    let hSolar = hourly.shortwave_radiation[hIdx];
                    let hWind = hourly.wind_speed_10m[hIdx];
                    let hVpd = calculateVPD(hourly.temperature_2m[hIdx], hourly.relative_humidity_2m[hIdx]);
                    
                    const typePenalty = (parkType === 'field') ? 0.5 : 0;
                    let radCool = (hourly.cloud_cover[hIdx] < 15 && hourly.shortwave_radiation[hIdx] < 10) ? 1.5 : 0;
                    
                    if (hGround <= (hDew + 0.5 + typePenalty + radCool) || precip > 0.1 || code >= 50) {
                        wasWet = true;
                        wetTime = i;
                        accumulatedDryingScore = 0; 
                    } else if (wasWet) {
                        accumulatedDryingScore += calculateDryingScore(hVpd, hWind, hSolar, parkType);
                    }
                }
            }

            // LOGIC
            let settings = getSettings(parkType, isMorning);
            let status = "DRY"; let color = "#2ecc71"; let sub = "GO SKATE";
            let logic = "Physics conditions look good.";
            let confidence = 0;

            let isRainingEffective = (lastRainHours === 0);
            if (parkType === 'covered' && wind < 20) isRainingEffective = false;
            let isSoggy = (parkType === 'field' && soilMoist > 0.35); 

            if (isRainingEffective) {
                status = "WET"; color = "#e74c3c"; sub = "RAINING"; logic = "It is raining right now.";
            }
            else if (spread < settings.margin) {
                status = "WET"; color = "#e74c3c"; sub = "SWEATING";
                logic = `<b>Active Condensation:</b><br>Ground (${groundTemp}¬∞) is too close to Dew Point (${dewPoint}¬∞).`;
                if (cloud < 20 && solar < 10) logic += "<br>Clear skies causing radiative cooling.";
            }
            else if (wasWet && parkType !== 'covered') {
                let dryingThreshold = (parkType === 'field') ? 3.0 : 1.5;
                if (isSoggy) accumulatedDryingScore *= 0.7; 

                let rawConf = (accumulatedDryingScore / dryingThreshold) * 100;
                if(rawConf > 95) rawConf = 95; if(rawConf < 5) rawConf = 5;
                confidence = Math.round(rawConf);

                if (accumulatedDryingScore < (dryingThreshold * 0.4)) {
                    status = "DAMP"; color = "#e74c3c"; sub = "LIKELY WET";
                    logic = `<b>Insufficient Energy:</b><br>It was wet ${wetTime}h ago.<br>Solar/Wind energy hasn't been enough.`;
                } else if (accumulatedDryingScore < dryingThreshold) {
                    status = "MAYBE"; color = "#f39c12"; sub = "CHECK SPOT";
                    logic = `<b>Partial Drying:</b><br>It was wet ${wetTime}h ago.<br>Evaporation Score: ${accumulatedDryingScore.toFixed(1)}.`;
                } else {
                    status = "PROBABLY DRY"; color = "#f39c12"; sub = "LOOKS OK";
                    logic = `<b>High Drying Energy:</b><br>It was wet ${wetTime}h ago.`;
                }
                
                if (isSoggy && status !== "WET") logic += "<br><b>Note:</b> Soil is saturated.";
            }
            else if (parkType === 'covered') {
                status = "DRY"; sub = "COVERED"; logic = "Spot is covered.";
            }

            // GLOBALS
            currentStatus = status;
            currentPrediction = "";

            // PREDICTION
            if (status !== "DRY" && status !== "PROBABLY DRY" && parkType !== 'covered') {
                const startAcc = (status === "WET") ? 0 : accumulatedDryingScore;
                const dryTime = predictDryTime(hourly, idx, parkType, startAcc);
                const predBox = document.getElementById('prediction-box');
                
                if (dryTime) {
                    const sunsetTime = daily.sunset[0].split('T')[1];
                    const isAfterDark = dryTime > sunsetTime;
                    
                    if(isAfterDark) {
                         predBox.innerHTML = `üèÅ Predicted Dry: ${dryTime}<br>‚ö†Ô∏è Will dry after dark (Sunset: ${sunsetTime})`;
                         predBox.className = "pred-warning";
                         currentPrediction = `Predicted Dry: ${dryTime} (After Dark)`;
                    } else {
                         predBox.innerHTML = `üèÅ Predicted Dry: ${dryTime}`;
                         predBox.style.background = "rgba(46, 204, 113, 0.15)";
                         predBox.style.color = "#2ecc71";
                         predBox.style.borderColor = "#2ecc71";
                         predBox.className = "";
                         currentPrediction = `Predicted Dry: ${dryTime}`;
                    }
                    predBox.style.display = "block";
                } else {
                    predBox.innerHTML = "üåßÔ∏è Won't dry in next 24h";
                    predBox.style.background = "rgba(231, 76, 60, 0.15)";
                    predBox.style.color = "#e74c3c";
                    predBox.style.borderColor = "#e74c3c";
                    predBox.className = "";
                    predBox.style.display = "block";
                    currentPrediction = "Won't dry today";
                }
            }

            // RENDER
            const head = document.getElementById('status-header');
            head.innerText = status; head.style.color = color;
            document.getElementById('status-sub').innerText = sub;
            document.getElementById('status-sub').style.color = color;
            document.getElementById('main-card').style.borderColor = color;
            document.getElementById('logic-box').innerHTML = logic;
            document.getElementById('why-btn').style.display = "block";

            document.getElementById('type-badge').style.display = "block";
            document.getElementById('type-badge').innerText = settings.desc;
            document.getElementById('type-badge').className = "badge type-" + (parkType === 'field' ? 'field' : (parkType === 'covered' ? 'covered' : 'urban'));
            
            const rainBadge = document.getElementById('rain-badge');
            rainBadge.style.display = "block";
            if (lastRainHours === 0) rainBadge.innerText = "Raining";
            else if (lastRainHours === -1) rainBadge.innerText = "No Rain >24h";
            else rainBadge.innerText = `Rain ${lastRainHours}h ago`;

            const confBadge = document.getElementById('conf-badge');
            if(confidence > 0) {
                confBadge.style.display = "block";
                confBadge.innerText = `${confidence}% Dry`;
                confBadge.className = "badge " + (confidence > 60 ? "conf-high" : (confidence > 30 ? "conf-med" : "conf-low"));
            } else { confBadge.style.display = "none"; }

            document.getElementById('data-card').classList.remove('dim');
            document.getElementById('val-sunset').innerText = daily.sunset[0].split('T')[1];
            document.getElementById('val-cloud').innerText = cloud + "%";
            document.getElementById('val-soil').innerText = (soilMoist*100).toFixed(0) + "%";
            document.getElementById('val-vpd').innerText = vpd.toFixed(2) + " kPa";

            const fCont = document.getElementById('forecast-container');
            fCont.innerHTML = "";
            for(let i=1; i<=3; i++) {
                const fIdx = idx + i;
                if(fIdx < hourly.time.length) {
                    const time = hourly.time[fIdx].split('T')[1];
                    const code = hourly.weather_code[fIdx];
                    const prob = hourly.precipitation[fIdx];
                    let desc = "Cloudy"; let tColor = "#aaa";
                    if(code < 3) desc = "Clear";
                    if(code >= 50) { desc = "Rain"; tColor = "#e74c3c"; }
                    const row = document.createElement('div');
                    row.className = 'forecast-row';
                    row.innerHTML = `<span class="f-time">${time}</span><span style="color:${tColor}">${desc} (${prob}mm)</span>`;
                    fCont.appendChild(row);
                }
            }
        }
    </script>
</body>
</html>
